# 【恶意代码图像 可视化和自动分类】2011
## ABSTRACT
二进制恶意代码可视化为灰度图，观察恶意代码家族，相同家族的可视化后结果相似。利用标准图片特征提出分类算法。分类不需要拆卸和执行代码。数据集：9000+样本，25个家族。我们的技术还展示了有趣的复原技术，例如部分加密等常用的混淆技术。

## INTRODUCTION
传统分析恶意代码方法：从中提取二进制签名，生成指纹。
我们的方法有静态码分析和动态码分析。静态分析包括拆卸代码，探索可执行文件的控制流，寻找恶意pattern。动态分析在虚拟环境下执行代码，基于执行轨迹生成表征可执行文件的行为报告。各有优缺点。静态方法提供更全面的覆盖，但面临加壳问题，可执行文件在分析前可能需要重打包或解密。动态方法不需要重打包和解密可执行文件，但是耗费时间资源，环境可能不符合某些触发条件，导致一些恶意行为被忽视。

本文提出完全不同的分析和分类恶意代码的方法。恶意代码可执行文件是二进制01串，将其reshape为矩阵，可视化为图像，相同家族的恶意代码图像有相似纹理。这也许可以解释为通过重复使用代码来创建新的恶意软件变体的常见做法。Sec2：恶意代码可视化和分类的相关工作。Sec3：将恶意代码二进制文件表示为图片。Sec4：一种图片分类->恶意代码分类。Sec5：实验细节。Sec6：方法局限性。现有的分类技术需要反汇编或执行，而我们的方法不需要，但仍然表现出性能方面的显着改进。此外，它也适用于流行的模糊处理技术，例如章节加密。这种自动分类技术应该对每天收到大量恶意代码的防病毒公司和安全研究人员非常有价值。

## Sec2：相关工作
文本和二进制编辑器可以看和操作二进制，还有一些对比文件的工具。
【3】self organizing maps检测和可视化可执行文件中的二进制代码。
【4】开发了逆向工程的可视化框架，他们通过节点链接（node-link）可视化确定功能区域并消除混淆。其中node表示地址，link表示地址之间的状态转换。【5】使用树形图显示操作的分布以及使用线程图的操作序列。【6】开发了可视化分析环境，帮助软件开发人员更好地理解代码。还展示了软件中的漏洞如何在其环境中可视化。
将恶意软件视为数字图像的研究较少。【8，9】将诸如文本，C ++数据结构，图像数据，音频数据的原始二进制片段的原始二进制数据可视化为图像。【7】可以利用统计特征自动分类二进制片段。他们的分析只涉及识别原始二进制碎片而不是恶意软件。 通过将恶意软件表示为灰度图像，本工作提供了类似的方法。
有一些恶意代码的聚类和分类技术。13-19静态分析，20-24动态分析.【24】使用恶意代码的行为特征分析，10000+样本的杀毒软件标注的数据集，分成14个恶意软件家族。在沙箱中检测所有恶意软件的行为，生成行为报告。报告生成每个恶意软件的特征向量，报告中为每个恶意代码生成特征向量，基于一些特定字符串的频率生成特征向量。用SVM训练和测试。准确率88%。【16】相比24使用了非常简单的特征，一个程序的长度，来分类7种不同类型的木马，只分析了721个文件，准确率88%。【17 18】相同作者，
使用恶意代码中可打印的字符串信息（printablestring information），分析13个家族1500+样本，准确率98.8%。【20】检测行为图中的最大公共子图进行分类，数据集300样本6个家族。
对比以上工作，本文工作不需要任何反汇编或执行实际恶意代码。用于分类的图像纹理在混淆技术方面提供更多弹性特征，尤其对于加密混淆。

## Sec3：可视化
恶意代码二进制，8bit无符号整型向量，组织成2维数组。可以可视化维灰度图[0，255]。图像的宽度是固定的，高度根据文件大小而变化。表1根据经验观察结果给出了不同文件大小的推荐图像宽度。
示例图片（注意各个二进制碎片含义？）。恶意代码的不同二进制片段表现出不同的图片纹理。各种原始二进制碎片的详细分类和它们作为灰度图像的可视化可以在[9]中找到。

【代码区、数据区、资源区】
.text：包含可执行代码。从图中可以看到.text的第一部分代码的包含纹理是细粒度的。剩下的是全0（黑色），说明这段的结束是0填充。
.data：包含未初始化的代码（黑色补丁）和初始化数据（细粒度纹理）。
.rsrc：包含模块的所有资源，这些可能还包括应用程序可能使用的图标。

## Sec4：恶意代码分类
经验观察上相同家族的恶意代码图像相似，不同家族的不同。这也许可以归因于re-use旧的恶意软件二进制文件来创建新的恶意软件。基于计算机视觉的方式分类。
### 4.1 图片纹理
关于视觉纹理的含义没有普遍接受的定义，但它通常与（重复）图案相关联。纹理研究三个方向：纹理分类，纹理分析和纹理合成。纹理分类涉及识别图像中的各种均匀纹理区域。纹理分割的主要目标是识别各种纹理区域的边界是。纹理合成方法用于合成纹理图像。它们经常用于计算机图形学。

纹理分析是计算机视觉领域的一个重要研究领域。大多数表面展现出一定数量的纹理。 纹理分析用于许多应用，包括医学图像分析，遥感和文档图像处理。恶意代码的图像纹理，虽然不完全是重复模式，展现出大量的“纹理”，并且该信息可以用于自动分类。
### 4.2 特征向量和分类器
针对纹理分析提出了一些特征。纹理分析最常用的方法之一是分析纹理块的频率内容(frequency content of a texture block)。标准方法将频域划分为环（scale）和楔形（方位），并在这些区域中计算特征。物理结果显示，人眼通过将图像分解成频率和方向分量来分析纹理。一个常用的纹理分析计算方法是使用Gabor filtering。二维Gabor函数由一定频率和方向的正弦平面组成，并由Gaussian envelope调制。Gabor filter是频率和方位选择过滤器，通过改变频率和方向，我们获得一组Gabor滤波器。 图像通过这个滤波器组来获得几个滤波图像，从中提取基于纹理的特征。一个这样的特征是通过计算来自滤波图像的变换值与小窗口内的均值的绝对平均偏差而获得的。使用Gabor滤波器的纹理特征在纹理分割和分类方面已经成功。
本文中使用类似的特征来描述和分类恶意软件。使用 GIST计算纹理特征，它使用图像的小波分解。这个特征成功应用在了场景和物体分类中。每个图像位置由调谐到不同方向和尺度的滤波器输出表示。我们使用8个方向的可控金字塔和4个尺度应用于图像。
图像的局部表示：  N=20，是子分支个数。
为了在重训练一些局部信息的同时捕获图片的全局属性，我们计算在大空间区域上平均的局部特征大小的平均值： 
W(x)是平均窗。
所得到的表示被降采样为具有M×M像素的空间分辨率（这里我们使用M = 4）。因此，m尺寸为M×M×N = 320，这是我们使用的GIST特征的尺寸。 有关GIST特征的更详细的解释可参见[12]
使用k近邻和欧氏距离做分类。测试采用10折交叉验证，在每次测试中，一个类的随机子集用于训练和测试。对于每次迭代，这个测试随机选择一个类的90％数据进行训练，10％进行测试。一个给定的测试数据被分类到它的k个最近邻居模式。

## Sec5：实验
实验中我们检查的恶意软件是提交给Anubis分析系统的恶意软件可执行文件[2]。被测试的样本因此是最新的恶意软件，可以在“wild”找到。 为了获得我们测试的ground-truth，我们使用Microsoft Security Essentials提供的标签将它们分类到不同的恶意软件家族。
### 5.1假设验证
为了验证相同家族的恶意软件具有可视化相似性，选取1713个恶意软件图片样本，分属8个恶意软件家族。浏览了这些图像的缩略图，并确认属于一个家庭的图像确实相似。用每张图片计算对应的GIST图片特征，平均计算时间是54ms/张。高维GIST特征被降维以进行可视化分析，观察特征点位置，Allaple.A, VB.AT, Wintrim.BX, Yuner.A and Fakerean类别被很好的分开了，但是Instantaccess, Obfuscator.AD和Skintrim.N在一块儿，肉眼观察它们的灰度图也很相似。但是分类器还是将其准确分开了。分类器k取3，10折交叉验证，最终准确率0.9993。平均超过10次测试，标准偏差为0.0019。
confusion matrix表：
A-H 8个恶意代码家族。335 ofInstantaccess (A), 485 of Yuner.A (B), 111 of Obfuscator.AD (C),80 of Skintrim.N (D), 298 of Fakerean (E), 88 of Wintrim.BX (F),97 of VB.AT (G) and 219 of Allaple.A (H)。
K取1到10结果相似，k取3准确性最高。
在向集合中添加来自Win32系统文件和应用程序的123个良性可执行文件之后，重复这些测试。新数据集上的分类准确率0.9929，10折交叉验证标准差为0.002。数据集可以从【30】（http://old.vision.ece.ucsb.edu/~lakshman）获得。
### 5.2 大规模实验
将分析方法扩展到表3，25类9458样本。Yuner.A, VB.AT,Malex.gen!J, Autorun.K, Rbot!gen家族的被UPX。这些解压缩的以进行初步分析。 然后重复上述测试，获得25个恶意软件家族的分类准确度0.9718。这些家族的图像可以从【30】获得。confusion matrix矩阵图6a可以看出，C2Lop.P，C2Lop.gen！g和Swizzor.gen！I，Swizzor.gen！E等家族之间存在混淆。 这些是C2Lop和Swizzor的变种。如果把他们组合成1个准确率提升到0.992。数据集添加额外可执行文件后准确率依然高达0.9808。
### 5.3 抵御混淆
迄今为止的分析一直在unpacked的可执行文件上进行。Packing会改变二进制文件的结构，因此Packing后的新二进制文件不再像unpacked的文件一样出现。但是，当属于同一家族的恶意软件被打包在同一个packed malware中时，我们推测打包的恶意软件的图像看起来很相似。因此这部分实验将同一家族的packed的恶意代码作为一个新的家族，重复上述实验，总的家族数变为29。仍然能做分类，准确率0.9808。
为避免使用打包程序，某些恶意软件家族将直接在其代码中嵌入多态引擎（polymorphic engines）。在我们的实验中最有代表性的例子是Allaple，其代码段在几个层中被使用随机密钥加密[29]。尽管如此，我们提出的方法也能够对这些样本进行分类。我们的方法可以成功的处理章节加密问题，因为它主要依赖于由多态引擎使用的弱加密方案保留的纹理信息。
### 5.4性能对比
使用静态特征进行分类的相关工作，基于bi-gram提取的分类似乎是普遍的方法，如[13]。为了衡量我们方法的性能。我们从数据集1（8个家族）提取bi-grams分布，bi-grams分布直接由元数据计算，不需要拆卸，但速度更慢。使用这种分布做特征向量，我们得到0.98的准确率，与我们自己的方法类似。但是平均提取时间为5s，分类一个样本需要56s。但是计算GIST只需54ms，分类需要1.4s，速度快40倍。部分原因是用于表征恶意软件图像的特征向量长度大约为320，而使用bigrams进行基于分布的分析需要大约65K个元素。

## Sec6：本文工作局限性
尽管基于图像处理分析恶意软件是一种新方法，但知道该技术的对手可以采取对策来击败系统，因为我们的技术基于全局图像的特征。反措施的一些例子可能是将二进制文件重定位或增加大量冗余数据。 为了解决这些攻击，我们将探索更多的本地化特征提取方案，考虑到恶意软件可执行文件及其原始二进制片段的不同特征[8,9]。一种可能的未来扩展是分割出图像区域，并表征这些纹理图案的局部纹理和空间分布。
另一个未来工作是利用恶意代码图像特征进行聚类，虽然聚类和分类相似，但前者是无监督的，后者是监督的。当前最先进的聚类算法[21]，[22]在精度和召回方面报告了高度准确的结果。然而，在最近的一篇论文中，Li等人[25] 对当前的聚类算法进行了性能评估，得出结论认为高精度是由于ground truth数据中的bias选择造成的。因此，现有技术聚类论文中报道的结果不可靠。
