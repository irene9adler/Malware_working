# Malware Classification and Class Imbalance via Stochastic Hashed LZJD

# 通过随机哈希LZJD实现恶意代码分类和类别平衡

## sec0：摘要
实现SHWeL特征向量表示：扩展了近期提出的LZJD（扩展LZ Jaccard距离），比原来的LZJD准确性高，比n-gram性能好，可以构建更高效的训练&推理算法。（n-gram训练时间长，LZJD推理部分耗时长）
可以解决类别不平衡问题，（恶意代码相关问任务中普遍出现）。
对比已有不平衡问题解决算法SMOTE，准确性更高，算法时间复杂度降低到O(N)。
可以用于任何字节序列分类问题。

## sec1： introduction
Malware用ML困难：1特征提取困难，缺少直觉和自然特征。恶意行为可能违反预期规则。
2标签数据获取困难。类别不平衡。

LZJD算法： 
恶意代码空间中的距离度量算法。度量任意字节序列的相似性。
改进自NCD算法：归一化压缩距离。应用于一系列malware任务。
LZJD+近邻分类器？对两类问题：恶意代码检测（二分类），恶意代码家族分类（多分类）准确性都更高。并且有真正的距离度量，因此可以用于相似性搜索、聚类等。
LZJD问题：没有构建恶意代码分类器，近邻搜索时间随训练集size线性增长，用SVM会增加推理时间。并且没解决不平衡问题。

本文扩展LZJD：1提升恶意代码分类准确性 2提升推理的时间性能，对于训练集size是不变量。3解决类别不平衡问题。
以上在同一框架内实现。
通过改进LZJD->产生固定长度的、稀疏特征向量，可方便的用逻辑回归等分类器分类。称为SHWel随机哈希加权LZ。通过新的过采样方法解决不平衡问题。
Sec4对比试验在几个不同数据及上评估SHWel向量比LZJD+近邻分类性能好。Sec5讨论为什么SHWel效果更好。

## sec2：相关工作
主要关注恶意代码空间的类别不平衡问题和不适用domain knowledge进行学习。
（1）	byte n-gram。这种空间最常用的方法。N-gram+随机森林。
问题：n值多时计算代价大。（特征百万）
难以用于监督学习分类之外，因为需要做特征选择。聚类和随机相似性搜索就不行。
（2）	NCD 归一化压缩距离：随机字节序列的相似性度量的方便方法。
通过独立的测量两个字节序列压缩后的size，两个序列连接后压缩后的size，通过序列级联节省空间的大小得到相似性度量。【malware任务用的多】
压缩的计算需求，只能用于小数据集。
（3）	LZJD：基于LZ的压缩算法，NCD算法改进。构建LZ压缩字典：一个原始二进制序列的子序列集合。用jaccard距离判定相似性，利用min-hash。
LZJD只是距离度量->解决分类：+knn或svm。推理时间随训练集size线性增长。
（4）不平衡问题。在检测（二分类）和多分类中都有，但解决的很少。

ML中解决这个问题的方法更常规：通过对训练数据的过采样和下采样。
1）	SMOTE算法：当前最成功的的不平衡解决算法。
对最小类进行过采样。对过采样点和其邻居点做插值以提升多样性。
2）	SMOTE变种：Borderline-SMOTE（B-SMOTE）限制为对靠近类别边界的点进行过采样。
ML中大多数类别不平衡解决方法的缺点：是为小数据集开发的。复杂度高（n方级），在训练集数量大时耗时长（需要o(n)级）。【这个复杂度应该是过采样操作本身的】
Malware问题中的类别不平衡：获取不同种类的正常代码的训练集难。个人PC中正常代码更多，外部网络设备中恶意文件更多。
决定训练集比例：
另一些方法选取平衡的训练集。
另一些方法是控制训练集和测试集类别比例一致。（不理想的方法）

## Sec3：SHWJ 随机哈希加权LZJD
LZJD：有效的距离度量   接nn（近邻）类的分类器准确性很好（nn分类器在常规用法中效果不一定好）。
大数据集场景：恶意代码数量指数级增长。
->设计一个方法可以利用LZJD的准确性，但比近邻搜索推理更快【inference阶段到底怎么理解？】。并且对于类别不平衡问题，分类器具有鲁棒性。（网络安全领域中，严重的类别不平衡是常见场景。）
Malware检测问题：获取大量字节的恶意代码很容易，但好的有代表性的正常数据获取很难。
Malware家族分类问题：不同恶意代码家族变种数量不同，一些恶意代码设计精妙。
策略：用LZJD向量化数据，解决上述挑战：
对比原始LZJD算法，3步实现目标：
1）	将子序列长度合并到相似性度量中，以获取额外信息，提高准确性。
2）	将字节序列数据转化为向量，以利用更快的算法，并高效合并第一步中的权重。
3）	在向量化中引入随机合并，从而实现一个字节序列的过采样，解决类别不平衡。

### 3.1 LZJD中的权重合并
原始LZJD算法：将原始字节序列A分解为m个子序列a1->am，子序列集合是无权的，但子序列长度不同。
直觉：两个原始序列有一个100+长度的子序列，和有一个长度为3的子序列，意义必然不同。->加权LZJD： 
直觉和TF-IDF加权模式相同。长序列重要性高。
在恶意代码领域这个假设很实用，因为padding可能在一个二进制文件中放上千的简单字节模式。
->加权jaccard相似性：
 
Min-hash：jaccard相似性本身可提供min-hash，加权jaccard sim则会丢失。
设一个字节序列有m个子序列，预期k个哈希值。LZJD生成min-hash时间O(m+klogk)。加权场景有多重策略，但生成size k的hash都要O(km)。
m：10到1000000，并且有百万级的原始字节序列。
所以小测试集上都会很大耗时。

3.2  合并哈希
3.3  合并随机性
Sec4 实验
4.1恶意代码分类
4.2恶意代码检测
4.3性能
Sec5 讨论
5.1 SHWeL相比SMOTE的提升
5.2 SHWeL和n-gram的关系
