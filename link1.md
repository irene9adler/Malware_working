### https://blog.csdn.net/omnispace/article/details/78118986
## 0x02 恶意代码图像
这个概念最早是2011年由加利福尼亚大学的Nataraj和Karthikeyan在他们的论文 Malware Images: Visualization and Automatic Classification 中提出来的，思路非常新颖，把一个二进制文件以灰度图的形式展现出来，利用图像中的纹理特征对恶意代码进行聚类。

国内这方面的研究较少，去年在通信学报上有一篇《基于纹理指纹的恶意代码变种检测方法研究》，是由北京科技大学的韩晓光博士和北京启明星辰研究院等合作发表的，目测也是仅有的一篇。

最简单的一种恶意代码图像绘制方法。对一个二进制文件，每个字节范围在00~FF之间，刚好对应灰度图0~255(0为黑色，255为白色)。将一个二进制文件转换为一个矩阵(矩阵元素对应文件中的每一个字节，矩阵的大小可根据实际情况进行调整)，该矩阵又可以非常方便的转换为一张灰度图。

如何用计算机发现和提取这些纹理的相似特征用以分类呢？这就需要用到计算机视觉里的一些技术了。在Nataraj和Karthikeyan的论文中采用的是GIST特征，GIST特征常用于场景分类任务(如城市、森林、公路和海滩等)，用一个五维的感知维度来代表一个场景的主要内容(详情请参考文献)。简单来说，输入图像，输出为对应的GIST描述符。

基于深度学习的图像识别系统的训练数据是一些有意义的图像。但这是一个非常有意思的巧合，至于基于深度学习的图像识别能否用于恶意代码图像的特征提取和分类，我认为是一个潜在的研究点，所能做的也不局限于此，如果有做深度学习的朋友可以伙同做安全的朋友一起研究交流。

## 0x03 OpCode n-gram
将n-gram应用于恶意代码识别的想法最早由Tony等人在2004年的论文N-gram-based Detection of New Malicious Code 中提出，不过他们的方法是基于ByteCode的。2008年Moskovitch等人的论文Unknown Malcode Detection Using OPCODE Representation中提出利用OpCode代替ByteCode更加科学。


## 0x04 决策树和随机森林
决策树是依靠我们的知识人工提取出来的特征。/依靠算法来寻找合适的特征构造决策树。
限于篇幅，决策树的构造等过程本文不进行展开，网上相关资源非常多。(只要能够充分理解熵和信息增益的概念，决策树其实非常简单)

随机森林：
将训练数据有放回的抽样出多个子集(即随机选择矩阵中的行)，当然在特征选择上也可以进行随机化(即随机选择矩阵中的列)，分别在每个子集上生成对应的决策树。

## 0x05 冠军队伍的实现细节
从.asm文件生成的图像，他们也没有使用GIST特征，而是使用了前800个像素值作为特征。
GIST特征与其他特征综合使用时影响整体效果，所以他们放弃了GIST特征，另外使用.asm文件生成图像纯属意外发现…
前800个像素，是通过反复交叉验证得出的，
生成opcode的n-gram n=4【代码】

特征：用到了.asm文件图像特征(前1500个像素)和OpCode n-gram特征(本实验取n=3,将总体出现频数大于500次的3-gram作为特征保留)

n-gram特征，保存成csv文件，用scikit-learn训练一个随机森林。
.asm文件图像特征也是用随机森林训练的。
最后把分别训练的结果结合。

发现.asm文件的前800个像素和反汇编代码没有关系！完全就是IDA产生的一些信息，更进一步的说，实际上冠军队伍的方法压根与恶意代码图像没有关系，实际上是用到了IDA产生的信息。真正复杂和耗时的部分在于特征选择和交叉验证上。

比赛的数据是去除了PE头的，而输入输出表对分析恶意代码是很有帮助的，假如微软提供的数据包含了PE头，将输入输出表作为特征，最终的结果应该还能进一步提升。
这个方法的能够发现一些静态方法发现不了的变种，但对于未知的新品种依然无能为力(没有数据，机器学习巧妇难为无米之炊…)
