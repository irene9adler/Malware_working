# 13-AISec  Structural Detection of Android Malware Using Embedded Call Graphs (tool: Adagio)  

## 方法：
Sec 2结构化恶意代码检测

基于两个关键发现：

1恶意功能集中在很少的函数里 

2相似恶意代码  代码重用以感染不同app
->识别代表已知恶意代码的函数调用图子图。（没有多项式时间的图同构性判定方法）
现有的match方法：图编辑距离，识别最大公共子图，
分类任务：基于核的SVM，图空间->图kernel：求图上的内积？ 已经被提出用于化学和生物信息学的图分类问题。
图kernel用于恶意代码检测任务：将代码抽象成一个表示，以学习其基础结构。
再将图kermel embedding到一个一致的向量空间。

## 方法步骤：
（1）	提取函数调用图+标注 ：根据指令标注每个节点。

（2）	计算邻居哈希：给每个节点计算一个哈希值，是通过其直接相连的邻居节点计算的。

（3）	Embedding到特征空间：用显式map embedding样本，使用邻居哈希的图kernel。   
Map的设计  评估特征空间中的内积等价于计算代表性的图核。【看不懂】

（4）	Learning和特征分析：训练线性SVM，二分类。然后使用显式特征空间突出显示可能包含恶意功能的应用程序中的子图

## 细节实现：
（1）	调用图提取和标注：
用Androguard框架提取调用图，节点用表示其内容的bit序列标注。
有向图表示：G=(V,E,L,l) L是label的子集（multiset），l是label函数V->L，设计：15个指令15个bits，node中出现过这个指令就置1否则为0。

（2）	邻居哈希
每个节点计算一个邻居哈希值，是将邻居节点压缩为一个单哈希值，计算：
 
R函数：单bit向左回转。
计算全图的邻居哈希：先单独计算每个节点的，再将原始节点label用哈希值替代。（聚集信息在邻居节点之间传递）
迭代应用邻居哈希：聚集邻居之间的信息到一个路径长度p，顺序p的邻居哈希用递归定义：G(p+1)=h(Gp)
用p=1限制特征空间复杂性。

（3）	特征空间embedding
Embedding的语义，是相似的sample内积要小？
邻居哈希图kernel函数，评估两个图的哈希后的相似个体子结构，是相同节点label的个数。（multiset L的交集size）
找到等价于图kernel的显式表示。
Multiset Lh的直方图H={a1,a2,…,an} ai表示第i个哈希值的出现，所以一共N个哈希值（N=2^n-1?）两个multiset中相同哈希值的计算可以通过给每个特定类型排序并计算两个multiset中都出现的类型的元素个数最小值(multiset的形态是啥？咋还有type)。
。。。
将直方图H map到P维空间：
 
维数P=M*N，N个bin，M是Bin中的最大值。

邻居哈希图kernel：
 
（4）	learning和特征分析
可解释性：计算直方图的每个bin聚集权重wi。如果这个wi很大，所有label的哈希值对应这个值的节点都对决策结果影响很大，可能是反应了恶意功能。
 
->最后画一个相关图，图中每个节点是其邻居节点权重和。

## 数据集：
13w+正常，1w+恶意，来自google play。Label：10个恶意嗲吗检测器，全不不报警的label为正常。

代码实现readme：
这些模块允许从一系列Android APK或DEX文件中提取和标记调用图，并应用显式特征映射来捕获其结构关系。 分析模块使用向量表示和svm提供用于设计二进制或多类分类实验。
