# usenix-15-Recognizing_Functions_in_Binaries_with_Neural_Network
# ck课上：利用NN从二进制文件中识别函数
## 问题定义：
代码C，二进制字节序列，每个∈（0，255），有n个函数，函数内有一定长度的二进制字节序列。将代码和函数定义为字节集合（不是指令集合）。
字节序列可能有多种不同的指令解码方法。因为每个字节可能属于一些可能的指令，基于字节做相比基于指令做可以避免歧义（？）
## 任务定义：
二进制代码C，没有关于函数的信息，4个任务：
（1）	函数起点识别
（2）	函数终点识别
（3）	函数边界识别：函数起终点正确组队，不是1、2task的简单合并。
（4）	通用函数识别（未做）
指标：presion、recall、F1。
例子：c代码和对应的二进制代码（不同编译平台，不同优化level）（图里给的是汇编代码。。。）
可以看出一个的函数起终点很好识别：起点是保存caller的栈帧，终点是retq。
另一个图的起终点不好识别，没有使用栈。Retq多次出现。
所以不能用简单的启发式方法（直觉条件判断）做。

## 方法：
RNN处理每个字节，判断是否是函数的起点。1个字节转为0-255实数，但是直接输入值就表示强度，不对，所以要embedding，用了one-hot，每个字节成为一个256维向量。后面又变成embedding为8维了（word2vec？）
在每个字节处做二分类，接softmax，loss求序列中每个位置的NLL和？
序列长度？

双向RNN、多层RNN

## 数据预处理：
对于这个task，直觉上不希望需要记住百万级字节的信息。但函数调用处可能离这个函数很远，。。。

从二进制中提取固定长度子序列，不用整个二进制。函数边界靠近子序列边界的可能性很小，有足够的信息判断函数的存在。
计算截断的子序列上的梯度需要迭代的次数少时间短。
将输入字节的顺序取反，源自直觉 函数开始  识别函数开始  RNN只能访问当前字节之前的位置，后面的不能，顺序取反可以帮助RNN学习。

## 数据集：
来自参考文献2的2000+二进制  大部分来自linux小部分来自win。编译器icc，gcc，VS。
训练时用RNN隐层节点，没用LSTM和GRU，一个隐层size16，每次在10万个1000字节的chunk上，共记取了长度10M。

## 未来工作：
（1）	模型内部机制的解释，分析向量结构，线性化网络状态，分析线性系统的特征向量，得到任务相关的信息（文献12）。理解网络如何在选择、整合、交互相关信息，允许线性系统识别特征向量，以无视不相关的信息。

（2）	对手可以得到神经网络的参数，利用其分析加入额外的指令，使得带有任务相关信息的特征向量不正交，从而影响RNN性能。
