# 15 UIC Master Disseration Heldroid：Fast and Efficient Linguistic-Based Ransomware Detection (tool: Heldroid)
## 方法：
### 一、	特征集
希望特征表示app行为，已有工作+一些自己的特征：静态挖掘行为模式、包名启发式、文件类型和数量、混淆、域名。。。 
会做特征选择，最终特征集较小。全部特征集在附录B。
（1）	权限：从xml文件中提取，编码成0/1。分为4类：恶意、有害、数据、通信。

（2）	Intent过滤器：也在manifest文件里定义，用于hook up系统和特定应用事件。
事件触发时，android会寻找每个定义了对应的intent filter的app&通知它。
也是从xml文件中提取，编码成0/1。限制了约20个认为有潜在危险的intent filters。

（3）	API调用：权限&intent filters：高level行为。API调用：实际的low-level内部工作。
通过反汇编样本&检查代码得到精确地调用了哪些API method。考虑所有method特征太多：用启发式方法去掉
AndRadar数据集的处理：提取每个样本的所有调用的API method，聚集到一个map，计算每个method的出现次数（在正常样本和恶意样本中），用条件概率计算score s。按s排序，剩几十个特征。

（4）	轻量级行为模式
静态提取的问题：独立，不关注外部环境。 对于一个被调用的API，加入一些复杂的表示具体行为的特征。->对源码做轻量级（有限深度）的可达性分析：
是否 启动发送短信，启动读取电话数据、收到短信时发送数据，向短号码发送短信、

（5）	启发式特征
手动检查了一些样本后设计出来的一些简单特征。（具体没懂）

（6）	资产和代码状态（数值）
APK文件数量，权限数量，activities和service。平均class size。总包数，main package的class数。

特征选择：共220+属性，用gain ratio选120。
分类算法和训练：DT，RF，SVM，规则学习器：JRip, FURIA, LAC, RIDOR。

### 二、	威胁文本检测
常规文本字符串  数字表示。
分割成句子（特定语言分割模型），去掉停用词，处理剩余词，提取词干。->特征空间，维数是所有主干词个数，出现为1否则为0。
训练集制作：手工从勒索软件中搜集句子转换成主干词向量，存到训练集T。运行时提取app数据字符串，用相同方式处理（从app额资源、网络流量中提取出的句子），将其与训练集中的数据对比得到一个score，用于0/1决策。
Score计算方法：（1）类似knn，计算与T中每个句子的余弦相似度，取最大值。
（2）	jaccard 距离
（3）后面的都看不懂  score增量。

### 三、	加密检测
流存在Environment.getExternalStorageDirectory() and Cipher.doFinal() or CipherOutputStream()   时有加密。
已知检测方法，所以用了一个第三方库。
为了完整性：一个真实app的流源检测例子。代码是加密流的source和sink。（代码是混淆过的人很难读懂）

### 四、	加锁检测
三种locking策略（问题：locking是干嘛）
设备锁：拒绝用户访问设备和app，电话变砖。一些实现方法：（1）直接和用户要管理员权限，然后锁屏。（2）生成无法退出的的全屏警报对话框，只有在输入正确的支付代码后才能解除该对话框。（3）捕获Home和Back按钮上的按键事件，以便受害者不再能够切换当前活动（即勒索软件活动）
针对以上策略的解决方法：
（1）	管理员锁：这个要想实现要申请管理员权限，然后调用 
DevicePolicyManager.lockNow()使设备像锁屏超时时一样。
申请管理员权限：需要BIND DEVICE ADMIN权限，加载intent 
android.app.action.ADD DEVICE ADMIN
manifest xml文件必须包含meta-data tag，确定android：resource属性指向一个包含一系列新管理员可以做的行为的配置文件。
检查配置文件（xml）和scan源代码序列即可。

（2）	导航抑制：
通过覆盖onKeyUp和onKeyDown方法实现。
检测这种行为的方法最trick：解析smali代码，找onKeyUp和onKeyDown方法的声明，
模仿body中的每个声明，验证返回值为true的执行路径的存在性。主要关注声明中对比key值和一个常数整数的，因为整代码和home（0x03）、back（0x04）有关。

（3）	不死对话：
从AlertDialog产生一个class，调用setCancelable(false)避免被用户取消。可以调用Window.setFlags  传递 参数作为flag包含FLAG SHOW WHEN LOCKED (0x00080000)以允许在锁屏时也能看到这个对话框。
利用程序切片找这类调用。
参数必须是常量值或“文字”，定义在在方法调用前的常量指示二进制代码中。还考虑了定义在class的其他部分的值。

## 实现：
（1）	静态分析：unpack用APK Tool。工具有缺点，不能正确unpack的样本就丢掉。
反汇编也用APK Tooldex字节码->smali（还有Jasmin、Jimple）。Smali代码静态分析工具只有一个：SAAF。
加密检测：FlowDroid。静态污点分析框架：内容、流、域、对象、生命周期发现。
只需输入source、sink。

（2）	NLP（威胁文本检测是本文核心部分）
语言识别任务：开源库langdetect。
分割：提取输入文本的有意义的单元（单词、句子、主题）：OpenNLP。可以创建特定语言模型句子模型，在用户提供的数据集（手工预分割句子生成的）上训练。
主干词分析器：	OpenNLP java实现：snowball。特定domain语言解码主干词。
停用词表：stop-words Project。

（3）	沙箱
将目标样本加载到模拟器，运行4-6分钟。网络嗅探器：app收发的流量都存文件（dump file），后续scan文件查找恶意文本。
类似TraceDroid的方法：模仿用户交互、重启、收发短信&电话。
【没说动态用的啥工具】
网络dump足够用以开始一个分析。
Andrubis：仿真工具选择。
文本分析技术 应用于从样本中提取出的string，尤其是来自内存dump的。 CopperDroid。

## 实验：
数据集：6个。
（1）	AndRadar：14w+正常样本。从应用市场爬，用VT标注正常和恶意。

（2）	AndroTotal：6k+恶意样本。

（3）	MalGenome：学术研究malware数据集。

（4）	ContagionMinidump：

（5）	勒索软件样本集1：确定的勒索软件。利用VT智能API查找样本，至少5个检测，包含关键字：。。。

（6）	勒索软件样本集2：潜在勒索软件。收集方式同上，但label不确定是勒索软件。可能有fp，我们有意省略了最后一次检查，因为该数据集将作为系统的不相交测试集。

